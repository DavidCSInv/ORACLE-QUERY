CRIANDO TABELAS COM CONSTRAINTS 

TIPOS DE CONSTRAINTS 

1 - NOT NULL
2 - UNIQUE
3 - PRIMARY KEY - QUANDO INFORMADA JÁ SETA COMO NOT NULL A COLUNA e é UNICA
4 - FOREIGN KEY
5 - CHECK

CONSTRAINTS SÃO LIMITAÇÕES PARA QUE QUANDO ALGUEM TENTAR ALGUMA AÇÃO QUE NÃO ESTA PERMITIDA PREVIAMENTE IRÁ OCORRER ERRO ORACLE

ELAS TAMBEM PODEM SER NOMEADAS E CASO NÃO TENHA NENHUM TIPO DE NOMEAÇÃO A MESMA IRÁ SER AUTONOMEADA, ELA PODE SER NOMEADA ANTES OU DEPOIS DE SUA
CRIAÇÃO

PODE SER DEFINIDA  TAMBEM A NIVEL DE TABELA OU DE COLUNA

DROP TABLE projects;
CREATE TABLE projects
(project_id    NUMBER(6)    NOT NULL,
 project_code  VARCHAR2(10) NOT NULL,
 project_name  VARCHAR2(100) NOT NULL,
 CREATION_DATE DATE DEFAULT sysdate NOT NULL,
 START_DATE    DATE,
 END_DATE      DATE,
 STATUS        VARCHAR2(20) NOT NULL,
 PRIORITY      VARCHAR2(10) NOT NULL,
 BUDGET        NUMBER(11,2) NOT NULL,
 DESCRIPTION   VARCHAR2(400) NOT NULL);
 
 
== CRIANDO TABELAS COM PRIMARY KEYS ===

== A NIVEL DE COLUNA ===

CREATE TABLE projects
(project_id    NUMBER(6)    NOT NULL
 CONSTRAINT PROJECTS_PROJECT_ID_PK PRIMARY KEY,
 project_code  VARCHAR2(10) NOT NULL,
 project_name  VARCHAR2(100) NOT NULL,
 CREATION_DATE DATE DEFAULT sysdate NOT NULL,
 START_DATE    DATE,
 END_DATE      DATE,
 STATUS        VARCHAR2(20) NOT NULL,
 PRIORITY      VARCHAR2(10) NOT NULL,
 BUDGET        NUMBER(11,2) NOT NULL,
 DESCRIPTION   VARCHAR2(400) NOT NULL);
 
 
==== A NIVEL DE TABELA  ====

CREATE TABLE projects
(project_id    NUMBER(6)    NOT NULL,
 project_code  VARCHAR2(10) NOT NULL,
 project_name  VARCHAR2(100) NOT NULL,
 CREATION_DATE DATE DEFAULT sysdate NOT NULL,
 START_DATE    DATE,
 END_DATE      DATE,
 STATUS        VARCHAR2(20) NOT NULL,
 PRIORITY      VARCHAR2(10) NOT NULL,
 BUDGET        NUMBER(11,2) NOT NULL,
 DESCRIPTION   VARCHAR2(400) NOT NULL,
 CONSTRAINT PROJECTS_PROJECT_ID_PK PRIMARY KEY (PROJECT_ID)); --- PODE SER INCLUSO MAIS DE UMA PRIMARY KEY AQUI SÓ ADICIONAR APÓS A VIRGULA
 
 ==== CONSTRAINT DE UNIQUE =====
 
 A MESMA É UM IDENTIFICADO DA TABELA
 GARANTE A INTEGRIDADE DA COMINAÇÃO DOS VALORES DAS COLUNAS QUE COMPOEM A CONSTRAINT UNIQUE SÃO UNICOS PERMITE NULO
 
 == NIVEL COLUNA =
 
DROP TABLE projects;
 
CREATE TABLE projects
(project_id    NUMBER(6)    NOT NULL
 CONSTRAINT PROJECTS_PROJECT_ID_PK PRIMARY KEY,
 project_code  VARCHAR2(10) NOT NULL
 CONSTRAINT PROJECTS_PROJECT_CODE_UK UNIQUE,
 project_name  VARCHAR2(100) NOT NULL,
 CREATION_DATE DATE DEFAULT sysdate NOT NULL,
 START_DATE    DATE,
 END_DATE      DATE,
 STATUS        VARCHAR2(20) NOT NULL,
 PRIORITY      VARCHAR2(10) NOT NULL,
 BUDGET        NUMBER(11,2) NOT NULL,
 DESCRIPTION   VARCHAR2(400) NOT NULL)
  
 
 == NIVEL DE TABELA ==
 
  
CREATE TABLE projects
(project_id    NUMBER(6)    NOT NULL,
 project_code  VARCHAR2(10) NOT NULL,
 project_name  VARCHAR2(100) NOT NULL,
 CREATION_DATE DATE DEFAULT sysdate NOT NULL,
 START_DATE    DATE,
 END_DATE      DATE,
 STATUS        VARCHAR2(20) NOT NULL,
 PRIORITY      VARCHAR2(10) NOT NULL,
 BUDGET        NUMBER(11,2) NOT NULL,
 DESCRIPTION   VARCHAR2(400) NOT NULL,
 CONSTRAINT PROJECTS_PROJECT_ID_PK PRIMARY KEY(PROJECT_ID),
 CONSTRAINT PROJECTS_PROJECT_CODE_UK UNIQUE(PROJECT_CODE) ) -- PODE TAMBEM SER ADICIONADO APOS MAIS 1 
 
 
 === CONSTRAINT DE FOREIGN KEY =====
 
 ELA SE REFERENCIA A OUTRA TABELA E ASSIM AMARRA AS  TABELAS
 
 SEUS INDICES NÃO SÃO CRIADOS AUTOMATICAMENTE E DEVEM SER REALIZADOS CRIADOS MANUAMENTE.
 
DESC PROJECTS;
 
DROP TABLE projects;

=== CRIANDO TABELAS NIVEL COLUNAS ===

CREATE TABLE projects
(project_id    NUMBER(6)    NOT NULL
 CONSTRAINT PROJECTS_PROJECT_ID_PK PRIMARY KEY,
 project_code  VARCHAR2(10) NOT NULL
 CONSTRAINT PROJECTS_PROJECT_CODE_UK UNIQUE,
 project_name  VARCHAR2(100) NOT NULL,
 DEPARTMENT_ID NUMBER(4) NOT NULL
 CONSTRAINT PROJECTS_DEPARTMENT_ID_FK REFERENCES DEPARTMENTS (DEPARTMENT_ID), --- VAMOS LÁ, A FOREIGN KEY TEM DE ESTAR REFERENCIANDO A MESMA COLUNA OU INFORMÇÃO DE PRIMARY KEY DE OUTRA TABELA
                                                                              --- ASSIM QUANDO FOR TRAZER ALGUMA INFORMÇÃO QUE AMBAS SEJAM REFERENCIADAS TEM COMO E NÃO IRÁ OCORRER ERRO
 CREATION_DATE DATE DEFAULT sysdate NOT NULL,
 START_DATE    DATE,
 END_DATE      DATE,
 STATUS        VARCHAR2(20) NOT NULL,
 PRIORITY      VARCHAR2(10) NOT NULL,
 BUDGET        NUMBER(11,2) NOT NULL,
 DESCRIPTION   VARCHAR2(400) NOT NULL)
 
 
 ===== CRIANDO CONSTRAINTS NIVEL TABELAS ====
 
 CREATE TABLE projects
(project_id    NUMBER(6)    NOT NULL,
 project_code  VARCHAR2(10) NOT NULL,
 project_name  VARCHAR2(100) NOT NULL,
 CREATION_DATE DATE DEFAULT sysdate NOT NULL,
 DEPARTMENT_ID NUMBER(4) NOT NULL,
 START_DATE    DATE,
 END_DATE      DATE,
 STATUS        VARCHAR2(20) NOT NULL,
 PRIORITY      VARCHAR2(10) NOT NULL,
 BUDGET        NUMBER(11,2) NOT NULL,
 DESCRIPTION   VARCHAR2(400) NOT NULL,
 CONSTRAINT PROJECTS_PROJECT_ID_PK    PRIMARY KEY(PROJECT_ID),
 CONSTRAINT PROJECTS_PROJECT_CODE_UK  UNIQUE(PROJECT_CODE),
 CONSTRAINT PROJECTS_DEPARTMENT_ID_FK FOREIGN KEY (DEPARTMENT_ID) REFERENCES DEPARTMENTS (DEPARTMENT_ID))
 
 
 ===== DELETANDO TABELAS COM FOREIGN KEYS ===
 
 REGRA DE DELEÇÃO - DEFAULT NO ACTION --- PADRÃO SEM VOCÊ DETERMINAR NADA
 
 CASO JÁ TENHA INFORMAÇÕES NA TABELA COM FOREIGN KEY IRA OCORRER ERRO.
 
 DROP TABLE TEAMS;
 
 CREATE TABLE TEAMS (
 PROJECT_ID NUMBER (6) NOT NULL,
 EMPLOYEE_ID NUMBER (6) NOT NULL,
 CONSTRAINT TEAMS_PROJECT_ID_FK FOREIGN KEY (PROJECT_ID) 
 REFERENCES PROJECTS (PROJECT_ID),
 CONSTRAINT TEAMS_EMPLOYEE_ID_FK FOREIGN KEY (EMPLOYEE_ID) 
 REFERENCES EMPLOYEES (EMPLOYEE_ID)
 )
 
 === FOREIGN KEY - REGRA DE DELEÇÃO - ON DELETE CASCADE
 
 
  CREATE TABLE TEAMS (
 PROJECT_ID NUMBER (6) NOT NULL,
 EMPLOYEE_ID NUMBER (6) NOT NULL,
 CONSTRAINT TEAMS_PROJECT_ID_FK FOREIGN KEY (PROJECT_ID) 
 REFERENCES PROJECTS (PROJECT_ID) ON DELETE CASCADE,  -- SE NA TABELA PAI FOR RETIRADO ALGUM VALOR NA FILHO QUE SERIA ESTA VAI SE ALTOMATICAMENTE TAMBEM RETIRADO
 CONSTRAINT TEAMS_EMPLOYEE_ID_FK FOREIGN KEY (EMPLOYEE_ID) 
 REFERENCES EMPLOYEES (EMPLOYEE_ID)
 )
 
 == FOREIGN KEY - REGRA DE DELEÇÃO - ON DELETE SET NULL -- É O MAIS RARO E QUASE NUNCA UTILIZADO
 
  CREATE TABLE TEAMS (
 PROJECT_ID NUMBER (6) ,
 EMPLOYEE_ID NUMBER (6) NOT NULL,
 CONSTRAINT TEAMS_PROJECT_ID_FK FOREIGN KEY (PROJECT_ID) 
 REFERENCES PROJECTS (PROJECT_ID)ON DELETE SET NULL,
 CONSTRAINT TEAMS_EMPLOYEE_ID_FK FOREIGN KEY (EMPLOYEE_ID) 
 REFERENCES EMPLOYEES (EMPLOYEE_ID)
 )
 
 == DEFININDO CONSTRAINT CHECK ===
 
 ELE NÃO PODE FAZER ESTE TIPO DE VALIDAÇÃO EM PSEUDOCOLUNAS COMO CURRVAL,NEXTVAL,LEVEL E ROWNUM
 NEM EM FUNÇÕES BASICAS DA ORACLE SYSDATE,UID,USER E USERENV
 TAMBEM NÃO SE PODE REFERENCIAS LINHAS DE OUTRAS TABELAS OU DA MESMA
 
 
  EXEMPLOS :
  
SELECT SYSDATE,UID,USER, USERENV ('LANGUAGE')
  FROM DUAL;
 
SELECT EMPLOYEE_ID,FIRST_NAME,ROWNUM  -- ROWNUM RETORNA A NUMERAÇÃO SEQUENCIA DA SAIDA DO SELECT
  FROM EMPLOYEES;
 
    ==== A NIVEL DA COLUNA ==
  
  DROP TABLE PROJECTS CASCADE CONSTRAINTS; -- LEMBRANDO ISSO DELETA AS CONSTRAINTS DAS OUTRAS TABELAS TAMBEM
  
  CREATE TABLE projects
(project_id    NUMBER(6)    NOT NULL
 CONSTRAINT PROJECTS_PROJECT_ID_PK PRIMARY KEY,
 project_code  VARCHAR2(10) NOT NULL
 CONSTRAINT PROJECTS_PROJECT_CODE_UK UNIQUE,
 project_name  VARCHAR2(100) NOT NULL,
 DEPARTMENT_ID NUMBER(4) NOT NULL
 CONSTRAINT PROJECTS_DEPARTMENT_ID_FK REFERENCES DEPARTMENTS (DEPARTMENT_ID),
 CREATION_DATE DATE DEFAULT sysdate NOT NULL,
 START_DATE    DATE,
 END_DATE      DATE,
 STATUS        VARCHAR2(20) NOT NULL,
 PRIORITY      VARCHAR2(10) NOT NULL,
 BUDGET        NUMBER(11,2) NOT NULL
 CONSTRAINT PROJECTS_BUDGET_CK CHECK (BUDGET > 0),
 DESCRIPTION   VARCHAR2(400) NOT NULL)
  
  ==== A NIVEL TABELA ====
  
   CREATE TABLE projects
(project_id    NUMBER(6)    NOT NULL,
 project_code  VARCHAR2(10) NOT NULL,
 project_name  VARCHAR2(100) NOT NULL,
 CREATION_DATE DATE DEFAULT sysdate NOT NULL,
 DEPARTMENT_ID NUMBER(4) NOT NULL,
 START_DATE    DATE,
 END_DATE      DATE,
 STATUS        VARCHAR2(20) NOT NULL,
 PRIORITY      VARCHAR2(10) NOT NULL,
 BUDGET        NUMBER(11,2) NOT NULL,
 DESCRIPTION   VARCHAR2(400) NOT NULL,
 CONSTRAINT PROJECTS_PROJECT_ID_PK    PRIMARY KEY(PROJECT_ID),
 CONSTRAINT PROJECTS_PROJECT_CODE_UK  UNIQUE(PROJECT_CODE),
 CONSTRAINT PROJECTS_DEPARTMENT_ID_FK FOREIGN KEY (DEPARTMENT_ID) 
 REFERENCES DEPARTMENTS (DEPARTMENT_ID),
 CONSTRAINT PROJECTS_BUDGET_CK CHECK (BUDGET > 0))
 
 
 ==== VIOLANDO AS CONSTRAINTS - COM ERRO ====
 
 INSERT INTO PROJECTS (PROJECT_ID,PROJECT_CODE,PROJECT_NAME,DEPARTMENT_ID,CREATION_DATE,START_DATE,END_DATE,STATUS,PRIORITY,BUDGET,DESCRIPTION)
 VALUES (1,'ERPIMP','ERP IMPLEMENTATION','77',SYSDATE,NULL,NULL,'Aproved','HIGH',10000000.00,'ORACLE ERP IMPLEMENTATION');
 
 -- PORQUE AQUI DEU ERRO, PELO SIMPLES FATO DE SUA CHAVE MÃE NÃO ESTE TIPO DE INFORMAÇÃO QUE VOCÊ ESTA QUERENDO INSERIR, OU VOCÊ INSERE ESTES DADOS NA TABELA MÃE OU COLOQUE OS DADOS 
 -- QUE JÁ EXISTE NA TABELA
 
 === VIOLANDO CONSTRAINTS - CORRIGIDO
  INSERT INTO PROJECTS (PROJECT_ID,PROJECT_CODE,PROJECT_NAME,DEPARTMENT_ID,CREATION_DATE,START_DATE,END_DATE,STATUS,PRIORITY,BUDGET,DESCRIPTION)
 VALUES (1,'ERPIMP','ERP IMPLEMENTATION','60',SYSDATE,NULL,NULL,'Aproved','HIGH',10000000.00,'ORACLE ERP IMPLEMENTATION');
 
 COMMIT;
 
 
 ========================================================================================================================================================================
 
 ==CONSULTANDO CONSTRAINTS PELO DICIONARIO DE DADOS 
 
 DESC USER_CONSTRAINTS;
 
 DESC USER_CONS_COLUMNS;
 
 
 SELECT CO.CONSTRAINT_NAME,
        CO.CONSTRAINT_TYPE, -- C = CHECK,R = FOREIGN KEY, U = UNIQUE, P = PRIMARY KEY
        CO.SEARCH_CONDITION, 
        CO.R_CONSTRAINT_NAME,
        CO.DELETE_RULE,
        CC.COLUMN_NAME,
        CC.POSITION,
        CO.STATUS
   FROM USER_CONSTRAINTS CO
   JOIN USER_CONS_COLUMNS CC ON (CC.CONSTRAINT_NAME = CO.CONSTRAINT_NAME
                                 AND CC.TABLE_NAME = CO.TABLE_NAME)
  WHERE CO.TABLE_NAME = 'PROJECTS'
  ORDER BY CO.CONSTRAINT_NAME,CC.POSITION;